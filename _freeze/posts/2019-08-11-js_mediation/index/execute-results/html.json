{
  "hash": "9759c21e58f327ecd80bca0a151c6244",
  "result": {
    "markdown": "---\ntitle: \"A Shiny App for JS Mediation\"\nauthor: \"CillianMacAodh (Cillian McHugh)\"\ndescription: A decription of how to make a Shiny App for mediation analyses\ndate: \"2019-08-23\"\naliases: \n  - js-mediation\nbibliography      : [\"../../bib/My Library.bib\"]\nlink-citations: true\nreading_time: true  # Show estimated reading time?\nshare: true  # Show social sharing links?\nprofile: false  # Show author profile?\ncomments: false  # Show comments?\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n\n# Background\n\nThis is a brief post about making [my first Shiny App](https://cillianmacaodh.shinyapps.io/JS_mediation/) ([see also](https://www.cillianmchugh.com/other/js-mediation-shinyapp/)).  I made this app following a meeting of the [Advancing Social Cognition lab (ASC-Lab)](https://asclab.wordpress.com/) where we discussed [this paper](https://perso.uclouvain.be/vincent.yzerbyt/Yzerbyt%20et%20al.%20JPSP%202018.pdf) by @yzerbyt_new_2018 proposing a new method for mediation analysis.  Any attempt to detail the differences in methods is well beyond the scope of a blog post.  The take home message is that the method proposed by @yzerbyt_new_2018 is less prone to Type I errors (or false positives) than the most commonly used methods [e.g., @hayes_introduction_2017].  In addition to identifying a problem and proposing a solution, the authors also provide the tools to implement their solution with an R package [@R-JSmediation].  Unfortunately, not everyone uses R, and this is why I set about developing a simple way for SPSS users to access this new method.\n\n# Regression and JS Mediation\n\nBefore I describe the [Shiny App](https://cillianmacaodh.shinyapps.io/JS_mediation/), I'll briefly demonstrate the 2 functions that are included in the [Shiny App](https://cillianmacaodh.shinyapps.io/JS_mediation/).  I'll use the built in dataset `mtcars` and investigate the relationship between 1/4 mile time (`qsec`), gross horsepower (`hp`) and weight (`wt`), specifically^[The purpose of this post is to demonstrate the code for these analyses, as such there may be issues with the analyses reported - I haven't checked any assumptions or anything.]:\n\n- does horsepower predict 1/4 mile time?\n- and is this relationship mediated by weight?\n\n## Set up the dataframe\n\nFor ease of reusing code (particularly later on) I'll save `mtcars` as a dataframe `df` and rename the variables of interest as `iv` (predictor variable), `dv` (outcome variable), and `mediator`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- mtcars          # create df from mtcars\n\n# create new variables with generic names\ndf$dv <- df$qsec      # save 1/4 mile time as dv\ndf$iv <- df$hp        # save horsepower as iv\ndf$mediator <- df$wt  # save weight as mediator\n```\n:::\n\n\n## Simple Regression\n\nBefore running the mediation I'll run a quick regression to assess the nature of the relationship between the variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- lm(dv ~ iv + mediator, data=df)  # save the regression in an object 'fit'\nsummary(fit)                            # show the results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = dv ~ iv + mediator, data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.8283 -0.4055 -0.1464  0.3519  3.7030 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 18.825585   0.671867  28.020  < 2e-16 ***\niv          -0.027310   0.003795  -7.197 6.36e-08 ***\nmediator     0.941532   0.265897   3.541  0.00137 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.09 on 29 degrees of freedom\nMultiple R-squared:  0.652,\tAdjusted R-squared:  0.628 \nF-statistic: 27.17 on 2 and 29 DF,  p-value: 2.251e-07\n```\n:::\n:::\n\n\nAs you can see from the output, 1/4 mile time is predicted by both horsepower and by weight.\n\n## Simple Mediation\n\nNow that we have a picture of the relationships between the variables we can run the mediation analysis. The code for this is detailed below. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nJS_model <- mdt_simple(data = df, # create an object 'JS_model'\n                       DV = dv,\n                       IV = iv,\n                       M  = mediator)\nadd_index(JS_model)               # display the results of the mediation\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest of mediation (simple mediation)\n==============================================\n\nVariables:\n\n- IV: iv \n- DV: dv \n- M: mediator \n\nPaths:\n\n====  ==============  =====  ======================\nPath  Point estimate     SE  APA                   \n====  ==============  =====  ======================\na              0.009  0.002  t(30) = 4.80, p < .001\nb              0.942  0.266  t(29) = 3.54, p = .001\nc             -0.018  0.003  t(30) = 5.49, p < .001\nc'            -0.027  0.004  t(29) = 7.20, p < .001\n====  ==============  =====  ======================\n\nIndirect effect index:\n\n- type: Indirect effect \n- point estimate: 0.00885 \n- confidence interval:\n  - method: Monte Carlo (5000 iterations)\n  - level: 0.05 \n  - CI: [0.00347; 0.0158]\n\nFitted models:\n\n- X -> Y \n- X -> M \n- X + M -> Y \n```\n:::\n:::\n\n\n- Here we can see that horsepower predicts both 1/4 mile time and weight.\n- There is also an indirect effect of horsepower on 1/4 mile time through weight.\n\n# Building a Shiny App\n\nThe full code for the app is below, for the next sections I'll go through some of the key pieces of code.^[In order to enable people to use the app for their own analysis I needed a way for them to upload their data into the app.  After a bit of googling I found [this example](https://gist.github.com/dgrapov/dfcf6ab2339b1cf19b090cfb8dadc855), for uploading .csv files.  I copied the code and modified it to include `read.spss()` from the package `foreign` instead of `read.csv()`]\n\n## The Geography of the Shiny App\n\nThe [Shiny App](https://cillianmacaodh.shinyapps.io/JS_mediation/) has two panels.\n\n- On the left we have:\n  - The data upload option\n  - A dropdown menu for selecting the data you wish to use (the uploaded file, the mtcars data set, or the iris data set)\n  - Dropdown menus for defining each of your variables,\n  - Text describing the App\n  \n- On the right we have:\n  - The output of the regression\n  - The output from the mediation analysis\n  \nThe code for generating these panels is below (comments above relevant lines describe the purpose of the various sections):\n\n```\n# UI for app\nui<-(pageWithSidebar(\n\n# We use headerPanel() to give a title to our app \n  headerPanel(\"JS Mediation\"),\n  \n# use sidebarPanel() to create the content of the side panel (panel on the left)\n  sidebarPanel\n  (\n# use fileInput() to create a dialogue for inputting a file\n    fileInput(\"file1\", \"Upload SPSS File\",\n              multiple = TRUE,\n              accept = c(\".sav\")),\n# create a horizontal line break\n    tags$hr(),\n    \n# create a dropdown menu for selecting the dataset to be used\n    selectInput(\"dataset\",\"Data:\",\n                choices =list(iris = \"iris\",\n                              mtcars = \"mtcars\",\n                              uploaded_file = \"inFile\"), selected=NULL),\n# create a dropdown menu for selecting the dependent variable to be used\n    selectInput(\"dv\",\"Dependent Variable:\", choices = NULL),\n# create a dropdown menu for selecting the Independent variable to be used\n    selectInput(\"iv\",\"Independent Variable:\", choices = NULL),\n# create a dropdown menu for selecting the mediator to be used\n    selectInput(\"mediator\",\"Mediator:\", choices = NULL) #,\n    \n# use HTML() to input formatted text describing the App\n    ,HTML('In response to \n    <a href=\"https://perso.uclouvain.be/vincent.yzerbyt/Yzerbyt%20et%20al.%20JPSP%202018.pdf\">this</a>\n    paper by Yzerbyt, Batailler and Judd (2018) which outined a new method of conducting mediation analyses\n    (with less susceptability to false positives than Hayes’ PROCESS) I created a ShinyApp so that their\n    R-package could be used by SPSS users. Upload your SPSS file above and select the variables you wish\n    to compare.')\n    ,br(),br(),br()\n    ,HTML('<p>Yzerbyt, V., Muller, D., Batailler, C., &amp; Judd, C. M. (2018). New Recommendations for\n    Testing Indirect  Effects in Mediational Models: The Need to Report and Test Component Paths.\n    <em>Journal of Personality and Social Psychology: Attitudes and Social Cognition</em>, 115(6), \n    929–943. <a href=\"http://dx.doi.org/10.1037/pspa0000132\"\n    class=\"uri\">http://dx.doi.org/10.1037/pspa0000132</a></p>')\n  ),\n  \n# use mainPanel() to create the panel on the right where the output of our tests will be\n  mainPanel(\n# give a title to the the first output\n    h3(\"Summary of Regression Model\"),\n# report the result of the regression, saved in the object 'fit'\n    verbatimTextOutput(\"fit\"),\n# give a title for the second output\n    h3(\"Mediation Results\"),\n# report the result of the mediation, saved in the object 'mediation'\n    verbatimTextOutput(\"mediation\")\n  )\n))\n\n```\n## The Backend of the Shiny App\n\nAbove we have the code for setting up and modifying the look and feel of our app. Below we go through the code for making the app do what it is supposed to do.  The code in full is at the bottom of this post, however I have isolated specific sections of code to describe their function.\n\n### Inputting data from file\n\nThe code below runs `read.spss()` on whatever file you have uploaded using the dialogue box in the side panel and creates a dataframe called `inFile`.\n\n```\n upload_data<-reactive({\n    inFile <- input$file1\n    if (is.null(inFile))\n      return(NULL)\n    read.spss(input$file1$datapath, to.data.frame = TRUE)\n  })\n  \n  observeEvent(input$file1,{\n    inFile<<-upload_data()\n  })\n\n```\n\n### Selecting data and variables\n\nThe code below retrieves information about the dataset that is selected, and displays the variables associated with the selected dataset in the dropdown menus for each of your variables (IV, DV, & mediator).\n\n```\n# update variables based on the data\n  observe({\n# make sure upload exists\n    if(!exists(input$dataset)) return() \n# retrieve names of columns (variable names) and save as 'var.opts'\n    var.opts<-colnames(get(input$dataset))\n# set var.opts as the options for the drop down menus\n    updateSelectInput(session, \"dv\", choices = var.opts)\n    updateSelectInput(session, \"iv\", choices = var.opts)\n    updateSelectInput(session, \"mediator\", choices = var.opts)\n  })\n```\n### Setting up data for analysis\n\nBelow we extract the data and variables selected in the dropdown menus and save them as objects that we can use in functions.  Specifically we create a list `obj` which contains the vectors `dv`, `iv`, and `mediator`.\n\n```\n \n# get data object\n  get_data<-reactive({\n    if(!exists(input$dataset)) return() # if no upload\n    check<-function(x){is.null(x) || x==\"\"}\n    if(check(input$dataset)) return()\n# retrieve the selected data and create objects and     \n    obj<-list(data=get(input$dataset),\n              dv=input$dv,\n              iv=input$iv,\n              mediator=input$mediator\n    )\n    \n# require all to be set to proceed\n    if(any(sapply(obj,check))) return()\n# make sure choices had a chance to update\n    check<-function(obj){\n      !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))\n    }\n    if(check(obj)) return()\n# return 'obj' on completion     \n    obj\n  })\n  \n```\n\n### Running the analyses\n\nNow that we can retrieve the selected data and variables, we can turn them into a dataframe and run our analyses on them.\n\n#### Regression\n\nThe code below creates an object `output$fit` which contains the output of the regression.\n\n```\n  output$fit <- renderPrint({\n# create an object 'data_list', which is a list that contains the selected data and variables\n    dataset_list <- get_data()\n    \n# isloate the elements in the list as separate objects    \n    a <- dataset_list$dv\n    b <- dataset_list$iv\n    m <- dataset_list$mediator\n    c <- dataset_list$data\n   \n# create a dataframe 'df' from the object 'c' the selected dataset    \n    df <- `colnames<-`(\n      cbind.data.frame(\n# we extract and use the variables from 'c' that have the same names as those selected\n        c[which(colnames(c)==a)],\n        c[which(colnames(c)==b)],\n        c[which(colnames(c)==m)]\n      ), c(\"dv\",\"iv\",\"mediator\"))\n# now we have a dataframe df with 3 variables named 'dv', 'iv', and 'mediator'\n\n# we need to ensure data is numeric\n    df$dv <- suppressWarnings(as.numeric(df$dv))\n    df$iv <- suppressWarnings(as.numeric(df$iv))\n    df$mediator <- suppressWarnings(as.numeric(df$mediator))\n    \n# using the same code previously discussed, we run the regression    \n    fit <- lm(dv ~ iv + mediator, data=df)\n    summary(fit) # show results\n    \n  })\n```\n#### Mediation\n\nBelow we follow mostly the same steps to create our dataframe, and this time we run the mediation instead of the regression.\n\n```\n  output$mediation <- renderPrint({\n# create an object 'data_list', which is a list that contains the selected data and variables\n    dataset_list <- get_data()\n    \n# isloate the elements in the list as separate objects    \n    a <- dataset_list$dv\n    b <- dataset_list$iv\n    m <- dataset_list$mediator\n    c <- dataset_list$data\n    \n# create a dataframe 'df' from the object 'c' the selected dataset    \n    df <- `colnames<-`(\n      cbind.data.frame(\n# we extract and use the variables from 'c' that have the same names as those selected\n        c[which(colnames(c)==a)],\n        c[which(colnames(c)==b)],\n        c[which(colnames(c)==m)]\n      ), c(\"dv\",\"iv\",\"mediator\"))\n# now we have a dataframe df with 3 variables named 'dv', 'iv', and 'mediator'\n    \n# we need to ensure data is numeric\n    df$dv <- suppressWarnings(as.numeric(df$dv))\n    df$iv <- suppressWarnings(as.numeric(df$iv))\n    df$mediator <- suppressWarnings(as.numeric(df$mediator))\n\n# and we run the mediation using the same code as at the beginning of this post    \n    JS_model <- mdt_simple(data = df,\n                           DV = dv,\n                           IV = iv,\n                           M  = mediator)\n    add_index(JS_model)\n  })\n```\n# Conclusion\n\nAbove I have described how I went about making my first [Shiny App](https://cillianmacaodh.shinyapps.io/JS_mediation/) which makes a new method of mediation analysis accessible to SPSS users.  Feel free to try it out (although I have not paid for a premium account with Shiny, so it might time out).\n\nBoth the `mtcars` dataset and the `iris` dataset are preloaded in the app if you want to try it but you don't have any SPSS files to upload.  If you are an R user hopefully this post might help you to make your own Shiny Apps to make R functionality available to your SPSS using colleagues.  Many thanks to the examples online that helped me, particularly [this example for uploading files and working with them](https://gist.github.com/dgrapov/dfcf6ab2339b1cf19b090cfb8dadc855).\n\n(also if you have any suggestions for improving the app, or if I have left anything out, let me know)\n\n\n```\nlibrary(shiny)\nlibrary(foreign)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(\"devtools\")\n#install.packages(\"JSmediation\")\nlibrary(JSmediation)\n\n\n\n# UI for app\nui<-(pageWithSidebar(\n  \n  # We use headerPanel() to give a title to our app \n  headerPanel(\"JS Mediation\"),\n  \n  # use sidebarPanel() to create the content of the side panel (panel on the left)\n  sidebarPanel\n  (\n    # use fileInput() to create a dialogue for inputting a file\n    fileInput(\"file1\", \"Upload SPSS File\",\n              multiple = TRUE,\n              accept = c(\".sav\")),\n    # create a horizontal line break\n    tags$hr(),\n    \n    # create a dropdown menu for selecting the dataset to be used\n    selectInput(\"dataset\",\"Data:\",\n                choices =list(iris = \"iris\",\n                              mtcars = \"mtcars\",\n                              uploaded_file = \"inFile\"), selected=NULL),\n    # create a dropdown menu for selecting the dependent variable to be used\n    selectInput(\"dv\",\"Dependent Variable:\", choices = NULL),\n    # create a dropdown menu for selecting the Independent variable to be used\n    selectInput(\"iv\",\"Independent Variable:\", choices = NULL),\n    # create a dropdown menu for selecting the mediator to be used\n    selectInput(\"mediator\",\"Mediator:\", choices = NULL) #,\n    \n    # use HTML() to input formatted text describing the App\n    ,HTML('In response to \n    <a href=\"https://perso.uclouvain.be/vincent.yzerbyt/Yzerbyt%20et%20al.%20JPSP%202018.pdf\">this</a>\n    paper by Yzerbyt, Batailler and Judd (2018) which outined a new method of conducting mediation analyses\n    (with less susceptability to false positives than Hayes’ PROCESS) I created a ShinyApp so that their\n    R-package could be used by SPSS users. Upload your SPSS file above and select the variables you wish\n    to compare.')\n    ,br(),br(),br()\n    ,HTML('<p>Yzerbyt, V., Muller, D., Batailler, C., &amp; Judd, C. M. (2018). New Recommendations for\n    Testing Indirect  Effects in Mediational Models: The Need to Report and Test Component Paths.\n    <em>Journal of Personality and Social Psychology: Attitudes and Social Cognition</em>, 115(6), \n    929–943. <a href=\"http://dx.doi.org/10.1037/pspa0000132\"\n    class=\"uri\">http://dx.doi.org/10.1037/pspa0000132</a></p>')\n  ),\n  \n  # use mainPanel() to create the panel on the right where the output of our tests will be\n  mainPanel(\n    # give a title to the the first output\n    h3(\"Summary of Regression Model\"),\n    # report the result of the regression, saved in the object 'fit'\n    verbatimTextOutput(\"fit\"),\n    # give a title for the second output\n    h3(\"Mediation Results\"),\n    # report the result of the mediation, saved in the object 'mediation'\n    verbatimTextOutput(\"mediation\")\n  )\n))\n\n\n# shiny server side code for each call\nserver<-(function(input, output, session){\n  \n  # update variables based on the data\n  observe({\n    #browser()\n    if(!exists(input$dataset)) return() #make sure upload exists\n    var.opts<-colnames(get(input$dataset))\n    updateSelectInput(session, \"dv\", choices = var.opts)\n    updateSelectInput(session, \"iv\", choices = var.opts)\n    updateSelectInput(session, \"mediator\", choices = var.opts)\n  })\n\n  # get data object\n  get_data<-reactive({\n    if(!exists(input$dataset)) return() # if no upload\n    check<-function(x){is.null(x) || x==\"\"}\n    if(check(input$dataset)) return()\n    \n    obj<-list(data=get(input$dataset),\n              dv=input$dv,\n              iv=input$iv,\n              mediator=input$mediator\n    )\n    # require all to be set to proceed\n    if(any(sapply(obj,check))) return()\n    #make sure choices had a chance to update\n    check<-function(obj){\n      !all(c(obj$dv,obj$iv,obj$mediator) %in% colnames(obj$data))\n    }\n    if(check(obj)) return()\n    obj\n  })\n  \n  upload_data<-reactive({\n    inFile <- input$file1\n    if (is.null(inFile))\n      return(NULL)\n    # could also store in a reactiveValues\n    read.spss(input$file1$datapath, to.data.frame = TRUE)\n  })\n  \n  observeEvent(input$file1,{\n    inFile<<-upload_data()\n  })\n  \n  \n  # create regression output  \n  output$fit <- renderPrint({\n    \n    dataset_list <- get_data()\n    \n    \n    a <- dataset_list$dv\n    b <- dataset_list$iv\n    m <- dataset_list$mediator\n    c <- dataset_list$data\n   \n    \n    df <- `colnames<-`(\n      cbind.data.frame(\n        c[which(colnames(c)==a)],\n        c[which(colnames(c)==b)],\n        c[which(colnames(c)==m)]\n      ), c(\"dv\",\"iv\",\"mediator\"))\n    \n    df$dv <- suppressWarnings(as.numeric(df$dv))\n    df$iv <- suppressWarnings(as.numeric(df$iv))\n    df$mediator <- suppressWarnings(as.numeric(df$mediator))\n    \n    fit <- lm(dv ~ iv + mediator, data=df)\n    summary(fit) # show results\n  })\n\n  # create mediation output  \n  output$mediation <- renderPrint({\n    \n    dataset_list <- get_data()\n    \n    a <- dataset_list$dv\n    b <- dataset_list$iv\n    m <- dataset_list$mediator\n    c <- dataset_list$data\n    \n    \n    df <- `colnames<-`(\n      cbind.data.frame(\n        c[which(colnames(c)==a)],\n        c[which(colnames(c)==b)],\n        c[which(colnames(c)==m)]\n      ), c(\"dv\",\"iv\",\"mediator\"))\n    \n    df$dv <- suppressWarnings(as.numeric(df$dv))\n    df$iv <- suppressWarnings(as.numeric(df$iv))\n    df$mediator <- suppressWarnings(as.numeric(df$mediator))\n    \n    JS_model <- mdt_simple(data = df,\n                           DV = dv,\n                           IV = iv,\n                           M  = mediator)\n    add_index(JS_model)\n  })\n  # #JS_model\n})\n\n\n# Create Shiny app ----\nshinyApp(ui, server)\n```\n\n# References\n\n\n<link rel=\"stylesheet\" href=\"{{ .Site.BaseURL }}/css/tomorrow-night-eighties.css\">\n<script src=\"{{ .Site.BaseURL }}/js/highlight.pack.js\"></script>\n<script>\n  hljs.initHighlightingOnLoad();\n</script>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}